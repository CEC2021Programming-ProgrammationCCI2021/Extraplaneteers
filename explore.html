<!--Creating Shape
var geometry = new THREE.BoxGeometry(1, 1, 1);

//create a material, color, or image texture
var material = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, wireframe: false });
var cube = new THREE.Mesh(geometry, material);
scene.add(cube);
-->
<!DOCTYPE html>
<html>

<head>
  <meta charset=UTF-8 />
  <link rel="stylesheet" type="text/css" href="./css/styles.css" />
</head>

<body>
  <script type="module">

    import * as THREE from './js/modules/three.module.js';
    import { FirstPersonControls } from './js/FirstPersonControls.js';
    import { OrbitControls } from "./js/modules/OrbitControls.js"
    //import Stats from './js/modules/stats.module.js';
    import { ImprovedNoise } from './js/ImprovedNoise.js';
    import { GLTFLoader } from './js/loaders/jsm/GLTFLoader.js';
    //import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";

    //Global Variables
    var stats;
    var camera, scene, renderer;
    var mesh, texture;
    var worldWidth = 256, worldDepth = 256
    var worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;
    var data = generateHeight(worldWidth, worldDepth);
    var clock = new THREE.Clock();

    function init() {

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
/*
      var geometry = new THREE.PlaneBufferGeometry(7500, 7500, worldWidth - 1, worldDepth - 1);
      geometry.rotateX(- Math.PI / 2);

      var vertices = geometry.attributes.position.array;
      
            for (var i = 0, j = 0, l = vertices.length; i < l; i++, j += 3) {
       
               vertices[j + 1] = data[i] * 5;
       
             }
       
      texture = new THREE.CanvasTexture(generateTexture(data, worldWidth, worldDepth));
      texture.wrapS = THREE.ClampToEdgeWrapping;
      texture.wrapT = THREE.ClampToEdgeWrapping;

      mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ map: texture }));
      scene.add(mesh);
*/
      renderer = new THREE.WebGLRenderer();
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      cam();
      controller();
      //FPSstats();
      twinkle();
      lights();
      addModels();

      window.addEventListener('resize', onWindowResize, false);

    }

    function cam() {
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000);
      camera.position.y = data[worldHalfWidth + worldHalfDepth * worldWidth] * 10 + 500;
    }

    function controller() {
      var controls;
      //controls = new FirstPersonControls(camera, renderer.domElement);
      //controls.movementSpeed = 1000;
      //controls.lookSpeed = 0.1;
      controls = new OrbitControls(camera, renderer.domElement);
    }

    /*  function FPSstats() {
          stats = new Stats();
          document.body.appendChild(stats.dom);
        }
    */

    var mixer;
    function addModels() {
      var loader = new GLTFLoader();
      loader.load(
        // resource URL
        //'./assets/DamagedHelmet/DamagedHelmet.gltf',       
        //'./assets/roboticArm.gltf',
        './assets/roboticArmAnimated.gltf',

        // called when the resource is loaded
        function (gltf) {
          scene.add(gltf.scene);

          mixer = new THREE.AnimationMixer(gltf.scene);
          var action = mixer.clipAction(gltf.animations[0]);
          action.play();

          //gltf.animations; // Array<THREE.AnimationClip>
          gltf.scene; // THREE.Group
          gltf.scenes; // Array<THREE.Group>
          gltf.cameras; // Array<THREE.Camera>
          gltf.asset;
        },

        // OPTIONAL: called while loading is progressing 
        function (xhr) {
          console.log((xhr.loaded / xhr.total * 100) + '% loaded');
        },

        // OPTIONAL: called when loading has errors
        function (error) {
          console.log('An error happened');
        }
      );

      loader.load(
        // resource URL
        //'./assets/DamagedHelmet/DamagedHelmet.gltf',       
        //'./assets/roboticArm.gltf',
        //'./assets/roboticArmAnimated.gltf',
        './assets/lunarTerrain/terrain_lunar.gltf',

        // called when the resource is loaded
        function (gltf) {
          scene.add(gltf.scene);

          mixer = new THREE.AnimationMixer(gltf.scene);
          var action = mixer.clipAction(gltf.animations[0]);
          action.play();

          //gltf.animations; // Array<THREE.AnimationClip>
          gltf.scene; // THREE.Group
          gltf.scenes; // Array<THREE.Group>
          gltf.cameras; // Array<THREE.Camera>
          gltf.asset;
        },

        // OPTIONAL: called while loading is progressing 
        function (xhr) {
          console.log((xhr.loaded / xhr.total * 100) + '% loaded');
        },

        // OPTIONAL: called when loading has errors
        function (error) {
          console.log('An error happened');
        }
      );
    }

    

    function lights() {
      var hlight = new THREE.AmbientLight(0x404040, 1);
      scene.add(hlight);

      let directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(0, 1, 0);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      let light = new THREE.PointLight(0xc4c4c4, 1);
      light.position.set(0, 300, 500);
      scene.add(light);

      let light2 = new THREE.PointLight(0xc4c4c4, 1);
      light2.position.set(500, 100, 0);
      scene.add(light2);

      let light3 = new THREE.PointLight(0xc4c4c4, 1);
      light3.position.set(0, 100, -500);
      scene.add(light3);

      let light4 = new THREE.PointLight(0xc4c4c4, 1);
      light4.position.set(-500, 300, 500);
      scene.add(light4);

    }

    function twinkle() {
      let galaxySize = 10000;
      let starGeo = new THREE.Geometry();
      for (let i = 0; i < 60000; i++) {
        let star = new THREE.Vector3(
          Math.random() * galaxySize - galaxySize / 2,
          Math.random() * galaxySize - galaxySize / 2,
          Math.random() * galaxySize - galaxySize / 2
        );
        starGeo.vertices.push(star);
      }

      let sprite = new THREE.TextureLoader().load('./assets/star.png');
      let starMaterial = new THREE.PointsMaterial({
        color: 0xaaaaaa,
        size: 0.7,
        map: sprite
      });

      let stars = new THREE.Points(starGeo, starMaterial);
      scene.add(stars);
    }

    function onWindowResize() {

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      controls.handleResize();

    }

    function generateHeight(width, height) {

      var size = width * height, data = new Uint8Array(size),
        perlin = new ImprovedNoise(), quality = 1, z = Math.random() * 100;

      for (var j = 0; j < 4; j++) {

        for (var i = 0; i < size; i++) {

          var x = i % width, y = ~ ~(i / width);
          data[i] += Math.abs(perlin.noise(x / quality, y / quality, z) * quality * 1.75);

        }

        quality *= 5;

      }

      return data;

    }

    function generateTexture(data, width, height) {

      var canvas, canvasScaled, context, image, imageData, vector3, sun, shade;

      vector3 = new THREE.Vector3(0, 0, 0);

      sun = new THREE.Vector3(1, 1, 1);
      sun.normalize();

      canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;

      context = canvas.getContext('2d');
      context.fillStyle = '#000';
      context.fillRect(0, 0, width, height);

      image = context.getImageData(0, 0, canvas.width, canvas.height);
      imageData = image.data;

      for (var i = 0, j = 0, l = imageData.length; i < l; i += 4, j++) {

        vector3.x = data[j - 2] - data[j + 2];
        vector3.y = 2;
        vector3.z = data[j - width * 2] - data[j + width * 2];
        vector3.normalize();

        shade = vector3.dot(sun);

        imageData[i] = (96 + shade * 128) * (0.5 + data[j] * 0.007);
        imageData[i + 1] = (32 + shade * 96) * (0.5 + data[j] * 0.007);
        imageData[i + 2] = (shade * 96) * (0.5 + data[j] * 0.007);

      }

      context.putImageData(image, 0, 0);

      // Scaled 4x

      canvasScaled = document.createElement('canvas');
      canvasScaled.width = width * 4;
      canvasScaled.height = height * 4;

      context = canvasScaled.getContext('2d');
      context.scale(4, 4);
      context.drawImage(canvas, 0, 0);

      image = context.getImageData(0, 0, canvasScaled.width, canvasScaled.height);
      imageData = image.data;

      for (var i = 0, l = imageData.length; i < l; i += 4) {

        var v = ~ ~(Math.random() * 5);

        imageData[i] += v;
        imageData[i + 1] += v;
        imageData[i + 2] += v;

      }

      context.putImageData(image, 0, 0);

      return canvasScaled;

    }

    function animate() {

      requestAnimationFrame(animate);

      var delta = clock.getDelta();
      if (mixer) mixer.update(delta);
      
      render();
      //stats.update();

    }

    function render() {

      //controls.update(clock.getDelta());
      renderer.render(scene, camera);

    }

    init();
    animate();
  </script>

  </script>
</body>

</html>